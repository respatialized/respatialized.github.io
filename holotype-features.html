<!DOCTYPE html>
<html><head><title>Respatialized | HOLOTYPE: blueprint</title><meta charset="utf-8"><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"><meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport"><link href="css/fonts.css" rel="stylesheet" type="text/css"><link href="css/main.css" rel="stylesheet" type="text/css"></head><body><article lang="en"><section><p>
</p><header><h1>HOLOTYPE: blueprint</h1><time datetime="2021-02-11">2021-02-11</time></header><p>Holotype will eventually become a library, distributable as an artifact separate from the context of its original creation. This page serves as a blueprint for that library.</p><figure><blockquote cite="http://nathanmarz.com/blog/suffering-oriented-programming.html">First make it possible. Then make it beautiful. Then make it fast.</blockquote><figcaption>Nathan Marz, <cite>Suffering-oriented programming</cite></figcaption></figure><p>Following Marz's advice, there will be three major phases of the work needed to make <code>holotype</code> a reality.</p><header><h3>Possible</h3></header><p>Because <code>holotype</code> exists mostly as idiosyncratic site generation code, I still need to make it <em>possible</em> to use outside of the context of this website. As Marz suggests, I am still feeling out the problem space in the context of a working prototype based on concrete examples.</p><p>As an example of following Marz's lead in building up the prototype in the context of concrete use cases, I generated the table below from an ordered map of features defined inline:</p><details><summary>Table source map</summary><code>{Preliminary API {:milestone "Possible", :status "Planned", :description "A first pass at a public API for the post helper functions"}, Generative testing {:milestone "Possible", :status "Partially implemented", :description "Leverage the HTML spec for high-performance testing"}, Database {:milestone "Possible", :description "Store post contents in a database"}, Schema {:milestone "Possible", :status "Partially implemented", :description "Spec for HTML elements and for database entries"}, Code cleanup {:milestone "Possible", :description "Remove references to old branches, experimental code, and other extraneous aspects of the codebase"}, Error handling {:milestone "Possible", :description "Surface parse/render errors in terminal and REPL"}, Configurable defaults {:milestone "Possible", :description "Override default template definitions + file extensions"}, Immediate rerenders {:milestone "Beautiful", :description "Refresh rerendered page content without manual browser reload"}, Stable API {:description "A stable API for post helpers and for programmatic interaction with parsing and rendering capabilities", :milestone "Beautiful"}, Autodocumentation {:description "HTML for holotype generated by holotype", :milestone "Beautiful"}, CLI / TUI {:description "Terminal commands for invocation and inpsection of builds", :milestone "Beautiful"}, Data-driven styling {:description "Constraint-based generation of CSS values", :milestone "Beautiful"}, Live Validation {:description "Incorporate schema definitions into error handling logic for real-time validation of HTML spec", :milestone "Beautiful"}, Async processing {:milestone "Fast", :description "Asynchronous parsing + rendering"}, On-disk cache {:milestone "Fast", :description "Persist parsed contents on disk for fast rebuilds"}}</code></details><p>
</p><details><summary><code>respatialized.render/map->table</code></summary><code>(defn
 map->table
 "Converts the map to a table. Assumes keys are row headers and values are maps of row entries (key:column/val:val). Optionally breaks up the table into multiple <tbody> elements by an additional attribute"
 ([m subtable-attr]
  (let
   [body-keys
    (->>
     m
     vals
     (map keys)
     flatten
     (into (ordered-set))
     ((fn* [p1__13536#] (disj p1__13536# subtable-attr))))
    header
    (->header (concat ["name"] body-keys))
    grouped-entries
    (->>
     m
     (group-by (fn [[e vs]] (get vs subtable-attr)))
     (map
      (fn
       [[grp ms]]
       [grp
        (into
         {}
         (map
          (fn [[entry vs]] [entry (dissoc vs subtable-attr)])
          ms))])))]
   (apply
    conj
    [:table header]
    (map
     (fn [[sub-val vm]] (map->tbody vm body-keys sub-val))
     grouped-entries))))
 ([m]
  (let
   [all-keys
    (->> m vals (map keys) flatten (into (ordered-set)))
    header
    (->header (concat ["name"] all-keys))]
   [:table header (map->tbody m all-keys)])))
</code></details><p>I didn't have that function before I wrote this post. Rather than writing a general-purpose 'table' function from scratch, I allowed the shape of the data that made the most sense at the time of writing to guide the implementation. A lot of this phase will consist of work like that: specific solutions that serve as data points for a new series of abstractions that unify the design.</p><header><h3>Beautiful</h3></header><p>In this phase, API stability will allow for new features to be built on a stable foundation while maintaining extensibility. I consider it an important goal that the <code>holotype</code> code be usable as a <em>library</em>, not as an opinionated and auto-configuring <em>framework</em>, which is what I hope a disciplined approach to API design will allow.</p><header><h3>Fast</h3></header><p>This phase will focus on improving the responsiveness of interactions with the library. Due to the importance of real-time feedback for users of the library, latency is to be prioritized over throughput.</p><header><h3>Table of features</h3></header><table><thead><tr><th>name</th><th>status</th><th>description</th></tr></thead><tbody><tr><th colspan="2">Possible</th></tr><tr><th scope="row">Preliminary API</th><td>Planned</td><td>A first pass at a public API for the post helper functions</td></tr><tr><th scope="row">Generative testing</th><td>Partially implemented</td><td>Leverage the HTML spec for high-performance testing</td></tr><tr><th scope="row">Database</th><td></td><td>Store post contents in a database</td></tr><tr><th scope="row">Schema</th><td>Partially implemented</td><td>Spec for HTML elements and for database entries</td></tr><tr><th scope="row">Code cleanup</th><td></td><td>Remove references to old branches, experimental code, and other extraneous aspects of the codebase</td></tr><tr><th scope="row">Error handling</th><td></td><td>Surface parse/render errors in terminal and REPL</td></tr><tr><th scope="row">Configurable defaults</th><td></td><td>Override default template definitions + file extensions</td></tr></tbody><tbody><tr><th colspan="2">Beautiful</th></tr><tr><th scope="row">Immediate rerenders</th><td></td><td>Refresh rerendered page content without manual browser reload</td></tr><tr><th scope="row">Stable API</th><td></td><td>A stable API for post helpers and for programmatic interaction with parsing and rendering capabilities</td></tr><tr><th scope="row">Autodocumentation</th><td></td><td>HTML for holotype generated by holotype</td></tr><tr><th scope="row">CLI / TUI</th><td></td><td>Terminal commands for invocation and inpsection of builds</td></tr><tr><th scope="row">Data-driven styling</th><td></td><td>Constraint-based generation of CSS values</td></tr><tr><th scope="row">Live Validation</th><td></td><td>Incorporate schema definitions into error handling logic for real-time validation of HTML spec</td></tr></tbody><tbody><tr><th colspan="2">Fast</th></tr><tr><th scope="row">Async processing</th><td></td><td>Asynchronous parsing + rendering</td></tr><tr><th scope="row">On-disk cache</th><td></td><td>Persist parsed contents on disk for fast rebuilds</td></tr></tbody></table><p>
</p></section></article><footer class="mb7"><div><a href="/">Home</a></div></footer></body></html>