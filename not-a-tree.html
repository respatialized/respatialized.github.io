<p><!DOCTYPE html>
<html><head><title>Respatialized | This Website Is Not A Tree</title><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport" /><link href="css/fonts.css" rel="stylesheet" type="text/css" /><link href="css/tachyons.min.css" rel="stylesheet" type="text/css" /></head><article lang="en"><body class="bg-moon-gray ml3 basier"><div class="f4 lh-copy mw9"></p>
<div class="b"><h1>This Website Is Not A Tree</h1></div>
<p><blockquote class="bl bw2 b--green w-60"><p class="f4 pl3 bold">It must be emphasized, lest the orderly mind shrink in horror from anything that is not clearly articulated and categorized in tree form, that the idea of overlap, ambiguity, multiplicity of aspect and the semilattice are not less orderly than the rigid tree, but more so. They represent a thicker, tougher, more subtle and more complex view of structure.</p><span class="pl3">Christopher Alexander, <a href="https://www.patternlanguage.com/archive/cityisnotatree.html">A City Is Not A Tree</a></span></blockquote>
<div class="f7 tr">essential reading.</div></p>
<p><div class="b"><h3>Preliminaries</h3></div>
<div class="f4">2019-03-10</div></p>
<p>This is the first post of respatialized, a website about actual and potential spaces. Part of the reason it took me so long to launch it is because nearly every static site generator forces your writing into a tree-like structure. Only one lets you extend the site generation methods to reflect your own ideas: Matthew Butterick's <a href="https://docs.racket-lang.org/pollen/">pollen</a> Because I want to combine the sequential and additive writing style of a blog with the associational and iterative nature of a wiki, this was the only choice.</p>
<p>It would have taken me even longer to get started if Joel Dueck hadn't already done the excellent work of creating  <code class="ws-normal navy"><a href="https://github.com/otherjoel/thenotepad">thenotepad</a></code>, which includes functions to produce many of the things we expect from blogs, like sequential indices and RSS feeds, and many that we should expect, but don't (like the ability to generate a PDF from the blog). The code that generates this blog is forked from  <a href="https://github.com/otherjoel/thenotepad">thenotepad</a> and licensed under the MIT License.</p>
<p><div class="b"><h3>Extensible Textual Notation</h3></div>
<div class="f4">2019-11-13</div></p>
<p>I recently switched from <code class="ws-normal navy">pollen</code> to <code class="ws-normal navy">perun</code>. <code class="ws-normal navy">perun</code>'s model of publishing everything via a composable collection of <code class="ws-normal navy">boot</code> tasks encapsulates everything that I want from <code class="ws-normal navy">pollen</code>'s organizational and compositional capabilities. <code class="ws-normal navy">pollen</code>'s pagetrees can be recreated by mapping and filtering the sequential collections of <code class="ws-normal navy">hiccup</code> data structures <code class="ws-normal navy">perun</code> generates, and applying those transformations to generic collections comes more readily to me than creating <code class="ws-normal navy">.ptree</code> files (the Clojure refrain, it's just data, etc.). My artwork and other content is also written in and generated using Clojure, so I don't want to have to drop into a different language that I don't know as well just to get it out. For me, the ability to iterate quickly depends on low friction and the power of simplicity: <code class="ws-normal navy">boot</code>'s Swiss army knife approach matches that perfectly. </p>
<p>However, I agree wholeheartedly with Matthew Butterick when <a href="https://docs.racket-lang.org/pollen/second-tutorial.html">he argues</a> that Markdown is a constraining environment in which to write, especially if you're looking to write a sustained treatment of a topic which usually generates a deep and rich collection of self and cross references and its own conventions for referring back to subtopics organically over time. Markdown supports the lowest level of this: links. Anything else, you're on your own, but with a completely restricted method of manipulating the input texts.</p>
<p>Also, sometimes I want to contextually distinguish textual elements using CSS and I want to do it without rewriting my markdown parser. I currently do this by littering my markdown posts with <code class="ws-normal navy">div class="..."</code> tags, which is kludgy and offers no way of systematically changing the classes applied to the textual element apart from doing find-replace on all of them with <code class="ws-normal navy">grep</code>.</p>
<p>The <code class="ws-normal navy">#lang pollen</code> directive provides a beautiful way of letting prose be prose while still letting you access the full power of a programming lanugage whenever you need it via the lozenge ◊ special character. </p>
<p>What I'm looking for, basically:
<pre class="ws-normal bg-light-silver code"><code>I'd like the ability to embed ◊(link hiccup "https://github.com/weavejester/hiccup")/clojure data structures into my textual input. They can either be data (see below) or functions called at render time that evaluate into data (see above).</p>
<p>[:em {:class "topic"} Extensibility]</p>
<p>Clojure already supports this notion in its canonical representation of data, extensibile data notation. I want to bring it to textual information, and maybe, HTML Canvas objects as well. The full power of a programming language means that we can flexibly switch between graphical and textual representations, something that pollen doesn't yet support.</code></pre></p>
<p>This approach also acts as a force-multiplier on immutable, compositional CSS tools like <code class="ws-normal navy">tachyons</code> or <code class="ws-normal navy">tailwind</code>, because it brings the power of Clojure into the tool you're using to write the text, which in turn leverages tools like <code class="ws-normal navy">tachyons</code> to apply a unified style to what you're writing using inline, simple notation.</p>
<p>Other examples in this space:</p>
<ul><li><code class="ws-normal navy">idyll</code></li><li><code class="ws-normal navy">mdx</code></li></ul>
<p>Both of these are built atop Javascript, and are more focused on interactivity for users than on procedural generation of text at write-time. Clojure(script)'s homoiconicity makes it ideally suited for both purposes- it can be used to generate interactive programs as well as any other form of data you'd want to display. I'm personally more interested in the latter, right now.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 2</h3></div>
<div class="f4">2019-11-17</div></p>
<p>Within the Clojure world and beyond, there are a few tools that suggest directions for what I'm thinking of here.</p>
<div class="b"><h4><code class="ws-normal navy">perun</code></h4></div>
<p>This is what I'm using to write and compile the blog itself right now. However, I don't like that most of the decisions about how to parse markdown into HTML are decided by the fiats of <code class="ws-normal navy">flexmark-java</code> I would much prefer to be able to manipulate the content in the form of  <code class="ws-normal navy">hiccup</code>  data structures as I see fit _before_ passing it to <code class="ws-normal navy">hiccup.core/html5</code> for rendering. <a href="https://github.com/hashobject/perun/issues/30">This was discussed</a> in the <code class="ws-normal navy">perun</code> repo, but was set aside when the use case of hyphenation didn' t actually require it.</p>
<p>However, there are many other reasons you'd be interested in representing your writing as data.
<blockquote class="bl bw2 b--green w-60"><p class="f4 pl3 bold"><em>if the book is a program, the source for that book should look more like your brain, and less like HTML (or XML or LaTeX or ...)?</em></p><span class="pl3"><a href="https://docs.racket-lang.org/pollen/second-tutorial.html">Matthew Butterick</a></span></blockquote></p>
<p>Personally, I'm interested in using the most powerful tools I have. For example, you could parse the writing into discrete chunks represented as <code class="ws-normal navy">hiccup</code> data structures, record them as facts in a <a href="https://github.com/tonsky/datascript"><code class="ws-normal navy">datascript</code></a> DB, and query them like any other source of data. This would be even more powerful if you ran it against not just the current state of your writing, but its revision history.</p>
<div class="b"><h4><a href="https://github.com/metasoarous/oz"><code class="ws-normal navy">oz</code></a></h4></div>
<p>As a Clojure enthusiast who got started with Jupyter notebooks, I quite like the idea of using Clojure for interactive documents. I just wish Markdown wasn't so uncritically accepted as the default for text authoring, because it seems silly to give yourself the whole power of a programming language in rendering a document and then arbitrarily restrict its scope to making graphs. Scientific documents in particular deal with lots of structured data: batteries of tests, statistical analyses, summary tables. Presentation of that data is not limited to graphs: a more powerful authoring model would allow you to dynamically generate and restructure the prose annotations of scientific data as easily as the graphs that summarize it. </p>
<p>Anything less feels like an arbitrary step backward.</p>
<div class="b"><h5>Code documentation tools</h5></div>
<p>The major area in which programmers _currently_ perform programmatic manipulation of prose and data in tandem is in the realm of documentation generators. In my experience, these tools fall into two broad categories:</p>
<p>- narrative-first tools like <code class="ws-normal navy">sphinx, reStructuredText</code>, etc. 
They have one primary benefit: if they're to be of any use at all they require the author to write a good amount of prose introducing the project, its rationale and purpose, and the main ways of interacting with it. However, in these tools, docs are generally separate from code - even if they live in the same repo, they're often in <code class="ws-normal navy">docs/</code> and can easily come out of sync with the actual code.
- code-first tools like any <code class="ws-normal navy">javadoc, docco, Roxygen2</code>, etc.
These have the benefit of being much closer to the day-to-day work of developers and are much less likely to become out of sync with the code, because they are usually parsed out of docstrings and special comments and the process of updating documentation can be built into a project's deployment pipeline without much overhead. The drawbacks? You generally end up with a completely decontextualized list of classes or functions that doesn't inform or give examples of how you'd actually <em>use</em> them. </p>
<div class="b"><h6><a href="https://gdeer81.github.io/marginalia"><code class="ws-normal navy">marginalia</code></a></h6></div>
<p><code class="ws-normal navy">marginalia</code> generates elegant-looking literate programming documents from plain Clojure source code. Like <code class="ws-normal navy">perun</code>, however, it returns rendered HTML rather than structured data from its parsing of source files. </p>
<div class="b"><h6><a href="https://github.com/namuol/cod"><code class="ws-normal navy">cod</code></a></h6></div>
<p>As a code documentation tool, <code class="ws-normal navy">cod</code> feels like it has the right idea at its core. Instead of deciding how to present the documentation it pulls out of the source code for you, <code class="ws-normal navy">cod</code> simply returns JSON data representing the annotations. Any further decisions about how to represent that JSON data in the final documentation are up to the author, allowing for a better blend of narrative and code than other documentation tools.</p>
<div class="b"><h6><a href="https://docs.racket-lang.org/scribble/"><code class="ws-normal navy">scribble</code></a></h6></div>
<p>The fact that Racket libraries tend to have _vastly_ superior documentation (on average) than any other programming language is a testament to the power of Scribble. Naturally, <code class="ws-normal navy">pollen</code> owes a lot to the starting point that <code class="ws-normal navy">scribble</code> created.</p>
<div class="b"><h5>Why look at code documentation tools?</h5></div>
<p>Mostly because I know that I'm going to have to write my own solution to this problem. I want the solution's source code to itself generate an example of the kind of document I want it to produce, so I'm hoping I can steal as many existing functions as possible from these other libraries while I'm bootstrapping the project.</p>
<p><div class="b"><h3>Structural features of writing and information management systems</h3></div>
<div class="f4">2019-12-14</div></p>
<p>I've gone through myriad to-do apps, organizers, journaling systems. Here's a table depicting my overall thoughts.</p>
<div><table><tr class=""><th>Type</th><th>Examples</th><th>Advantages</th><th>Disadvantages</th></tr><tr class="mr1"><td>Binder notebook</td><td>Filofax</td><td>associative,organic,frictional,multi-modal,simple</td><td>atemporal,apresentist</td></tr><tr class="mr1"><td>Diary</td><td>Bullet journal</td><td>chronological,frictional,reflective,multi-modal,simple</td><td>apresentist</td></tr><tr class="mr1"><td>To-do app</td><td>Nozbe, todoist</td><td>fast,simple,portable</td><td>decontextualized</td></tr><tr class="mr1"><td>Kanban</td><td>Trello</td><td>situated,simple</td><td>decontextualized,information-poor</td></tr><tr class="mr1"><td>free-form/wiki</td><td>Notion</td><td>associative,compositional,iterative</td><td>hierarchical,laborious</td></tr><tr class="mr1"><td>Website</td><td>This</td><td>frictional,multi-modal,associative</td><td>laborious,atemporal</td></tr></table></div>
<p>All of these advantages and disadvantages stem from one real underlying issue, in my view: each tool imposes its own view over the data you put into it, making alternative ways of looking at the same information difficult or impossible. Paul Chiusano has <a href="https://pchiusano.github.io/2016-10-13/view-inspired.html">written nicely</a> about the conceptually weak data model an "intuitive" design imposes on the information it represents:</p>
<blockquote class="bl bw2 b--green w-60"><p class="f4 pl3 bold">We often think about views first because views are concrete, and it’s what we interact with directly when we use software. But actually designing software ‘view first’ is problematic because it leads to rigid models that aren’t flexible enough to support the myriad of creative ways that people use your software. It also leads invariably to feature creep—when your model is overly influenced by some concrete views you had in mind during design, it invariably ends up insufficiently general purpose. So as your software becomes more popular, you start adding one-off ‘features’ to support concrete use cases that your users are asking for. A few years pass of this feature creep, and you have a bloated, complicated piece of software that no one gets joy out of using.</p><span class="pl3">Paul Chiusano<a href="https://pchiusano.github.io/2016-10-13/view-inspired.html">The design failures of view-first</a></span></blockquote>
<p>Every to-do list and knowledge management system suffers from this problem, In fact, I can feel the constraints imposed by the table above limiting what I want to say about each tool, so let's dive into what I mean by each of these words:</p>
<ul><li><strong>associative</strong> - topics and items added at different times can be seen side-by-side, permitting recontextualization of existing information.</li><li><strong>organic</strong> - order emerges from what is added rather than being imposed.</li><li><strong>frictional</strong> - the extra effort required to add additional material actually performs useful work rather than being a hindrance (a benefit that has thus far made handwritten notes more valuable to me than digital ones).</li><li><strong>multi-modal</strong> - multiple systems of representation can be easily employed in the same context.</li><li><strong>atemporal</strong> - the system has no direct representation of the temporal ordering of its contents.</li><li><strong>chronological</strong> - the system has a direct representation of the temporal ordering of its contents.</li><li><strong>reflective</strong> - the system provides opportunities for reflection.</li><li><strong>apresentist</strong> - the system has no direct representation of what's "current."</li><li><strong>fast</strong> - adding information is quick and reliable.</li><li><strong>simple</strong> - the system itself does not impose barriers to adding additional information.</li><li><strong>portable</strong> - information can be added and recalled through multiple mechanisms or devices.</li><li><strong>decontextualized</strong> - information or items are cut off from their surrounding context.</li><li><strong>non-iterative</strong> - the system does not support the process of refining information added to it; it expects items in their "final state."</li><li><strong>deep</strong> - the system supports long-form treatments of the information added to it</li><li><strong>hierarchical</strong> - the system requires information to be organized in a tree format, thwarting associational views of it.</li><li><strong>situated</strong> - the system provides useful background information without getting in the way of the work the information is intended to support.</li><li><strong>compositional</strong> - underlying data, through association, can be <em>composed</em> into higher-level information.</li><li><strong>laborious</strong> - the effort required to add or revise material imposes costs rather than providing benefits.</li></ul>
<p>Most recently, I've been using a Zettelkasten-style system for my notes with a filofax binder. It's superb for free association, quick entry, and the generative friction that only putting pen to paper can provide. It's not so good for revisiting previous notes, synthesizing them into new information, reflecting on the past, or maintaining a view of what's "current." Before that, I used a journal-style notebook that was similarly good at quick free-form entry and helped maintain a chronological view of things that aided in reflection, but failed to support associational views of the information recorded within it and similarly suffered from difficulties in keeping things current. I think a two-phase system that facilitates the refinement of paper "drafts" into digital "facts" would be ideal for me, personally.</p>
<p>Many digital systems for doing this exist already. I chafe at using them because they all uncritically accept that markdown is a useful format for representing semantically rich textual information, and then shoehorn features on top of it to make up for its limitations.</p>
<p>Obviously, I'm also taking notes here instead of on paper. Writing this doesn't provide exactly the same generative friction as pen and paper, but does a good enough job of forcing me to clarify my thoughts through the pressure of putting them in a public format. I also have complete control over the content (once I can overcome the limitations of markdown). Given that what I write has currently a 1:1 file:destination relationship, it also prevents association and composition of the information I record here. Ideally you'd want to break this input/output link, which would support both private views of some information and also let you think about how to refer to the same piece of information from multiple public views.</p>
<p>The question on how to <a href="https://plato.stanford.edu/entries/information-semantic/">individuate pieces of information</a> is permanently open, so an ideal system would support "contention" in that it can facilitate multiple methods of splitting up and representing a topic. How to do that on a technical level is obviously also an open and extremely difficult problem.</p>
<p>It seems daunting to come up with a solution for this, but I've been reading about something that may offer a partial way out recently: Datascript, mentioned in passing earlier. Where Chiusano proposes algebraic data types to manage this, I would prefer to start with datoms that get freely composed into views through datalog queries. Pieces of information (or even bits of writing themselves) would be decomposed down into EAVT facts and recorded in some persistent database where they can change in the future without fear of losing knowledge by revising it.</p>
<p>There's a lot more to say on the design of this, but mostly I wanted to get this concept "on paper" for further development into a design.</p>
<p><div class="b"><h3>Structural features of writing and information management systems, part 2</h3></div>
<div class="f4">2019-12-15</div></p>
<p>Another distinction that cuts across everything that I referenced in that table above is the idea of <em>closed</em> versus <em>open</em> knowledge management systems. While my notebook has acquired a significant amount of internal complexity, it is largely a <em>closed</em> system, making interaction with other sources of information more difficult. I have a gigantic pinboard backlog, highlights in a kindle, scattered paper notes about physical books, and no means of integrating them or refining them into something more meaningful.</p>
<p>A lot of PIMs designed to support academic reseearch are "open" towards producing and consuming the primary objects of academic research: papers and monographs. I'm not an academic. While writing helps me clarify my ideas, I also need tools oriented towards the work I do in programming, which means supporting a more <em>situated</em> understanding of what I'm doing. By that I mean supporting a "keep this in mind as you act" understanding of something rather than a "discrete textual description" understanding of something. In cybernetics terms, one might say that my information management systems have not had the <em>requisite variety</em> to handle the tasks I want them to support. They are not <em>open</em> to non-textual workflows. </p>
<p>Here's a quick sketch of what this might be look like:</p>
<div><img alt="views-sketch" class="w-30" src="media/views_sketch.jpg" /></div>
<p>The bottom has a pomodoro-style task tracker and the "current task", the right pane has a grouping of recent commits to keep the actual output of that task in mind as well. The role of these panes isn't the important part - the mechanism by which they're generated is. By pulling information from a common store, simple contextual visualizations of relevant parts of it would be easy to construct via Datalog queries. </p>
<p>A further source of information comes from the seemingly simple fact that these pieces of information are <em>displayed together</em>. The entities referenced by the views currently active could be linked through additional queries - for example, the commits happening in the text editor could create corresponding entities with attributes linking them to the entity of the current task. Similarly, information entries updated when a text file is open or a namespace is edited could be linked with that text file. This establishes a notion of <em>relevance</em> for the supporting materials of the work being done.</p>
<p><div class="b"><h3>This website (could be) a CRDT</h3></div>
<div class="f4">2019-12-26,2019-12-28</div></p>
<p>While considering potential applications of <a href="https://respatialized.net/relay.html">relay</a> software, I recalled the notion of a <em>conflict-free replicated data type</em>, a data structure that provides a probably correct solution to the problem of imposing a total order on a sequence of edits to a file that arrive out of order, editing different subsets of text, with unreliable timestamps. This data type would be what you reach for if you were designing a collaborative text editor with online and offline editing capabilities, because it would save you from making hard choices about which text to discard and which to keep (or worse, making the user deal with any errors caused by your software and imposing those choices on them).</p>
<p>I started reading about the concept, glossing over the mathematical details in favor of an interest in its potential as an expressive medium for thought. Some ideas that fell out of this:</p>
<div class="b"><h5>Making the library metaphor in 'code library' concrete</h5></div>
<div><p class="f5"><em>heavily inspired by Rich Hickey's talk<a href="https://youtube.com/watch?v=oyLBGkS5ICk">Spec-ulation</a></em></p></div>
<p>Right now you have to take home the whole library when you write some code that uses one page of one book.</p>
<p>Statically typed languages that rely on complex class hierarchies, especially because the compiler may make multiple passes across the codebase for definitions in different files ("... all you wanted was the banana." - Joe Armstrong) force you to ship all this supporting material to use one part of it. </p>
<div><p class="f5"><em>aside: I don't intend this as an intrinsic dig at statically typed, compiled languages per se. Smart compilers can do dead code elimination, but usually this technique is put to the purpose of reducing </em> executable <em>size rather than reducing</em> dependency <em>size. It'd be very interesting to see a compiler targeting library code that minimizes the volume of the library code pulled in by the code which declares it as a dependency.<a href="https://www.unisonweb.org/docs/tour">Unison</a> has done some interesting work in this direction because of its ability to serialize algebraic data types and send them over the network to perform remote computation.</em></p></div>
<p>So if instead of classes defined across files or nested relationships between algebraic data types defined at compile time, we had functions operating on simple, immutable values defined in self-contained s-expressions, plus some annotations:</p>
<p><pre class="ws-normal navy bg-silver"><code>(defn myfunc
 {:calls #{this.ns/func other.ns/func}
...)</code></pre>
<em>this could maybe be achieved even without the manual annotation if you used a macro to pull the symbols out of the function expression at compile time</em></p>
<p>Rather than a scope defined by a global namespace of evaluated expressions, these explicit references define exactly what a function needs to be lifted out of its lending library and used independently of the codebase it came from.</p>
<em>to make an analogy to Unison above, using <code class="ws-normal navy">core.spec</code> plus these dependency annotations means that the functions would be addressed by</em> contract <em>rather than by</em> content. <em>I think that Unison's emphasis on making functions immutable is a good one, but annotating the contract rather than the internals may do a better job of preserving intent for a dynamically typed language.</em>
<p>S-expressions would slot naturally into the delimited data structures required by a CRDT, making this serialization easy (other programming languages may have a harder time). This opens up another application:</p>
<div class="b"><h5>New forms of revision control</h5></div>
<p>CRDTs can contain arbitrary series of revisions to the same underlying data, in a method guaranteed to converge on a consistent result.</p>
<p>Documentation could be stored in the same CRDT. If the documentation has old timestamps, a tool could be built atop them to warn the user or author that they're stale relative to the rest of the code. Test results could be stored with the hash of the CRDT at the time they were executed, making failing tests trivial to reproduce. With a clever index, the failing tests associated with a given function could be recalled from the codebase's history with a query, providing useful context for finding the source of an unexpected regression.  </p>
<em>again, this requires a language with an unambiguous syntax and referential transparency to be truly effective - I make no claims to being fair to non-lisp programming languages.</em>
<p>Configuration for external systems, or expressions that modify it, could be stored in the same CRDT as the code itself. Integration and system tests could be linked with configuration changes in the manner I describe above, providing context for when the components of a distributed system fail and are made to work again. </p>
<p>Tests could be shipped around with their functions using a similar annotation syntax to the one above so that someone can have guarantees about the external code they're relying on.</p>
<div class="b"><h5>A notebook for the table beside your hammock</h5></div>
<p>If code and documentation are part of the same data structure as a whole, then an "ideas first" approach to software is as easy to start and maintain as a new experimental repo. The recorded ideas can evolve in tandem with the code that implements them, and their interplay gets expressed through the immutable history of the data structure recording them. It's an environment that makes hammock-driven development as easy as flow-state coding and bug squashing, with the ability to fluidly switch between them without breaking the flow. Code itself as one component part of an open system that doesn't treat writing down the problem and writing the code that solves it as separate activities.</p>
<p>What else is possible? Right now, code takes on the shape that Git repositories, and the software we use to interact with them, want it to take. Can we break code revision history and reuse out of the paradigm of discrete individual repositories? Is a distributed data structure like this enough to make the distinction between "monolithic" and "microservice-oriented" code obsolete? </p>
<p>Alex Miller <a href="https://news.ycombinator.com/item?id=20365854">writes of</a> the new model embraced by <code class="ws-normal navy">deps.edn</code>:</p>
<blockquote class="bl bw2 b--green w-60"><p class="f4 pl3 bold">deps was designed to find a sweet spot in the middle of this with deps defined as data, aliases capturing program executions as data, but builds as programs. As such, the scope is drastically narrowed in deps to just a) building classpaths (by resolving dependency graphs) and b) launching programs. As such, this tends to be a dramatically simpler model to start with (your initial deps.edn can be empty), and a model that is easy to understand as you scale up. I think there is more to do in how we model "tools" (esp tools shared across projects) and program composites, but nothing prevents you from building these yourself if needed (as you have the full power of Clojure at your disposal).</p><span class="pl3">Alex Miller</span></blockquote>
<p>Storing code in a CRDT has the potential to explore new parts of the misty space between "tools" and "programs" for Clojure code. I'm definitely interested in where this could lead, but I have to figure out how to create s-expressions from my prose first. </p>
<em>Oh, and by the way, the formal term for the structure that emerges from a properly implemented CRDT is a</em> <a href="http://archagon.net/blog/2018/03/24/data-laced-with-history/">monotonic semilattice</a>. <em>Which, according to Christopher Alexander in the essay I quote above, is exactly the form required to capture the interdependent complexity of a city.</em>
<p><div class="b"><h3>Extensible Textual Notation, part 3</h3></div>
<div class="f4">2019-12-28</div></p>
<div class="b"><h5>Structure from text</h5></div>
<p>I want to replicate <code class="ws-normal navy">pollen</code>'s ability to let prose be prose while still incrementally bringing in a programming language when it's needed, but also combine it with Clojure's own data structures to capture the structure that emerges organically from the act of writing, so I could, for example, capture the table above not just as a sequence of textual elements but also preserve the structure of the tabular data itself for future use somewhere else. </p>
<p>The simplest implementation of that would be just reading in the file line by line and constructing maps from the paragraphs separated by line breaks:</p>
<p><pre class="ws-normal navy bg-silver"><code>{:id e4268ac2
 :text "Paragraph one."}
{:id e4268ac3
 :text "Paragraph two."}
</code></pre></p>
<p>The initial reading process creates entities that serve as placeholders for text as it is when read and as it may be in the future, all recorded as facts in a EAVT/RDF semantic triple format. Knowledge atoms instead of data atoms. But a collection of facts doesn't preserve the ordering of their original composition, which is a lot of structure to throw away. There are two ways of preserving it that initially occurred to me:</p>
<p>[1] <strong>files are entities too</strong> - just have them refer to their contents as distinct entities.</p>
<p><pre class="ws-normal navy bg-silver"><code>{:entity 23542
 :attribute :filename
 :value "plaintext-file.txt"}
{:entity 23542
 :attribute :contents
 :value [52952 29587 29042]}
</code></pre></p>
<p>In this mode, order of paragraphs is asserted as a fact on the basis of the vector of entity ids of the constituent paragraphs.</p>
<p>[2] Alternatively, the facts about the paragraph order could just be <strong>composites of other facts</strong>:</p>
<p><pre class="ws-normal navy bg-silver"><code>{:entity 23542
  :attribute :contents
  :value [{:uuid ab50234 :text "opening paragraph goes here"}
          {:uuid ab50235 :text "second paragraph goes here"}]}
</code></pre></p>
<p>I don't really like 2. it feels ad-hoc and non-relational, whereas 1 seems more relationally correct but is semantically not as rich as an individual fact. This shortcoming is easily resolved by a query to pull in the relevant text, however. </p>
<p>Speaking of which:</p>
<div class="b"><h5>Text from structure</h5></div>
<p>When thinking about where to store this data, I was led to James Smothers' <a href="https://github.com/smothers/cause"><code class="ws-normal navy">cause</code></a>, a very well-documented Clojure implementation of a causal tree, a type of CRDT. It places the notion of a <code class="ws-normal navy">CausalBase</code> front and center, which sounds great, except it doesn't quite have the power implied by the "database" referred to by its name - which is generally okay in Clojure because the language already has pretty powerful facilities for quick operations on collections of maps. </p>
<p>But what if someone went further than that, combining a CRDT with a data model and query engine like in DataScript? Turns out in describing that I'm describing <a href="https://github.com/replikativ/datahike"><code class="ws-normal navy">datahike</code></a>, a Datalog implementation atop the <code class="ws-normal navy">hitchiker-tree</code> CRDT. </p>
<p>With existing text snapshotted as facts and recorded in a CRDT, queries could be run against that data to associate formerly disparate pieces of data into new forms, and the composites those queries create could themselves be recorded and annotated as new facts about the collection. The query that retrieves those facts could be stored as data itself, with the new structure that the query identifies added as an annotation to it. Use these queries and the expressive power they create to give a new life to <code class="ws-normal navy">structur</code> and <code class="ws-normal navy">alpha</code>, the venerable software extensions to <code class="ws-normal navy">Kedit</code> written by Howard J. Strauss to aid <a href="https://www.newyorker.com/magazine/2013/01/14/structure">John McPhee in his writing process.</a></p>
<blockquote class="bl bw2 b--green w-60"><p class="f4 pl3 bold"><p>He listened to the whole process from pocket notebooks to coded slices of paper, then mentioned a text editor called Kedit, citing its exceptional capabilities in sorting. Kedit (pronounced 'kay-edit'), a product of the Mansfield Software Group, is the only text editor I have ever used. I have never used a word processor. Kedit did not paginate, italicize, approve of spelling, or screw around with headers, WYSIWYGs, thesauruses, dictionaries, footnotes, or Sanskrit fonts. Instead, Howard wrote programs to run with Kedit in imitation of the way I had gone about things for two and a half decades.</p><p>He wrote Structur. He wrote Alpha. He wrote mini-macros galore. Structur lacked an “e” because, in those days, in the Kedit directory eight letters was the maximum he could use in naming a file. In one form or another, some of these things have come along since, but this was 1984 and the future stopped there. Howard, who died in 2005, was the polar opposite of Bill Gates—in outlook as well as income. Howard thought the computer should be adapted to the individual and not the other way around. One size fits one. The programs he wrote for me were molded like clay to my requirements—an appealing approach to anything called an editor.</p><p>Structur exploded my notes. It read the codes by which each note was given a destination or destinations (including the dustbin). It created and named as many new Kedit files as there were codes, and, of course, it preserved intact the original set. In my first I.B.M. computer, Structur took about four minutes to sift and separate fifty thousand words. My first computer cost five thousand dollars. I called it a five-thousand-dollar pair of scissors.</p><p>I wrote my way sequentially from Kedit file to Kedit file from the beginning to the end of the piece. Some of those files created by Structur could be quite long. So each one in turn needed sorting on its own, and sometimes fell into largish parts that needed even more sorting. In such phases, Structur would have been counterproductive. It would have multiplied the number of named files, choked the directory, and sent the writer back to the picnic table, and perhaps under it. So Howard wrote Alpha. Alpha implodes the notes it works on. It doesn’t create anything new. It reads codes and then churns a file internally, organizing it in segments in the order in which they are meant to contribute to the writing.</p><p>Alpha is the principal, workhorse program I run with Kedit. Used again and again on an ever-concentrating quantity of notes, it works like nesting utensils. It sorts the whole business at the outset, and then, as I go along, it sorts chapter material and subchapter material, and it not infrequently arranges the components of a single paragraph. It has completely served many pieces on its own.</p></p><span class="pl3"><a href="https://www.newyorker.com/magazine/2013/01/14/structure">John McPhee, Structure</a></span></blockquote>
<p><a href="https://docs.racket-lang.org/pollen/">The book is a program</a>. Tools for writing digital books should be at least as powerful as the tools created for conventional books decades ago. CRDTs provide a reliable and immutable foundation to the discrete chunks of knowledge that McPhee has used for his entire career. A query engine provides the toolkit to devise new ways of composing them together as powerful as <code class="ws-normal navy">structur</code> and <code class="ws-normal navy">alpha</code>, but with the added benefit of an entire programming language so that the text (or the collection of notes used to produce it) is no longer a closed system but can instead pull in data from the rest of the world. </p>
<p><div class="b"><h3>The Markdown Cargo Cult</h3></div>
<div class="f4">2019-12-29</div></p>
<blockquote class="bl bw2 b--green w-60"><p class="f4 pl3 bold">First and worst, Markdown isn’t semantic.</p><span class="pl3"><a href="https://docs.racket-lang.org/pollen/second-tutorial.html">Matthew Butterick</a></span></blockquote>
<p>I view basically every other problem with Markdown as downstream from this. Like Butterick, I'm utterly baffled by the degree to which everyone developing new types of interactive authoring tools simply assumes that everyone will want to write text in a format that's completely blind to the organic structure that emerges from ordinary writing. <a href="https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Working%20With%20Markdown%20Cells.html">Jupyter notebooks</a>,  <a href="https://www.mkdocs.org/">documentation tools</a>, <a href="https://github.com/metasoarous/oz/blob/be700e721fd758024f0783083279132afc42f317/examples/test.md">interactive documentation tools</a>, <a href="https://github.com/nteract/nteract/blob/f94502e4ff654bb58166bff262f133d4f449b049/packages/outputs/src/components/media/markdown.md">interactive data science toolboxes</a>, <a href="https://idyll-lang.org/docs/syntax">JS-based explorable explanation tools</a>,  <a href="https://github.com/witheve/Eve/commit/fa1700cb37198d1a02ebbaaa506c70c40b201d76">revolutionary new prototypes of combined programming languages and visual environments</a>, <a href="https://github.com/mhuebert/maria/blob/88776252f16ccacb23fb63d83223186b8cd55f8b/editor/src/maria/commands/prose.cljs">further explorations of how programming could be different</a>, all of them voluntarily choosing to tie the millstone of this impoverished format around their necks despite serious attempts to rethink the combination of code and prose. </p>
<p>Why do we use it? Because one of <a href="https://daringfireball.net/projects/markdown/">Apple's court intellectuals decided it was convenient for him?</a></p>
<blockquote class="bl bw2 b--green w-60"><p class="f4 pl3 bold">How is Markdown innovative exactly? It took ideas from the 70s, dropped the interesting parts, and was hailed as a revolutionary approach to marking up documents. Ie, the past 30 years of computing have been about narrowing the interface between programmer and computer to the equivalent of a straw (everything as text!) and then try to build an entire system around that.</p><span class="pl3"><a href="https://news.ycombinator.com/item?id=16230676">Spotted on Hacker News</a>, the only reasonable response to someone calling Markdown 'a triumph of programmer ergonomics.'</span></blockquote>
<p>Every system built atop Markdown will invariably have some ad-hoc and kludgy method of attempting to recapture some part of the structure that emerges from text authored in markdown, and it will be different from every other one because Markdown is blind to structure in all but the most basic of ways. In that regard it is very similar to "plain-text configuration" tools like <a href="/against-metadata.html">YAML</a>, which have all kinds of templating engines bolted on to them to overcome the limitations of what has in practice become a flat-file key-value store.</p>
<p><em>Everyone already knows markdown! It's fast and easy!</em></p>
<p>Just be aware of what you're giving up as an author in pursuit of that, and what you may be imposing on yourself later on down the line if you want to overcome these constraints.</p>
<p>And yes, there's no small irony in the fact that the <a href="https://gitlab.com/respatialized/respatialized.gitlab.io/blob/master/content/not-a-tree.md">source code for this post</a> is currently written in Markdown. It is indeed fast and easy to get started writing with it, but I'd largely attribute that to path dependence, and the fact that my particular parser leaves the <code class="ws-normal navy">div</code> tags I've littered throughout this post intact, which is an accident of choosing to use <code class="ws-normal navy">perun</code> and thereby <code class="ws-normal navy">flexmark-java</code> rather than the virtues of the format itself. I have every intention of changing the authoring tool I use into something semantically richer, but I had to get my resistance to the format on paper first.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 4</h3></div>
<div class="f4">2019-12-29</div></p>
<div class="flex"><div class="w-40"><img alt="" class="w-50" src="media/thinking-about-things.jpg" /></div><div class="pl3 w-40"><blockquote class="bl bw2 b--green w-60"><p class="f4 pl3 bold">I read relentlessly. I don’t do any programming not directed at making the computer do something useful, so I don’t do any exercises. I try to spend more time thinking about the problem than I do typing it in.</p><span class="pl3"><a href="http://web.archive.org/web/20160918041754/http://codequarterly.com/2011/rich-hickey/">Rich Hickey</a></span></blockquote></div></div>
<p><em>inspiration for what the medium should make possible, and for my prose-first approach to thinking about it: Bret Victor's laptop sticker and Rich Hickey's mindset; the antithesis of the "shut up and show me the code" brogrammer ethos</em></p>
<div class="b"><h5>Beyond plain text: storing prose within<code class="ws-normal navy">datahike</code></h5></div>
<p>Here's a <a href="https://blog.datopia.io/2018/11/03/hitchhiker-tree/">background post on the Datahike internals</a> for context about how the hitchhiker B-tree structure allows for self-balancing and efficient updates that "hitchhike" on queries.</p>
<p>Here's another on using the <code class="ws-normal navy">dat://</code> protocol for <a href="https://lambdaforge.io/2019/12/08/replicate-datahike-wherever-you-go.html">P2P replication of the data stored in a Datahike instance</a>. It serves as a useful starting point for getting a Datahike instance up and running.</p>
<p>Here's what would be a useful starting point for programmatic prose parsing: including a quotation in a piece of prose writing that gets parsed as a separate component and then added to a global list of quotations maintained by the text parser, with a link back to its original positional context within the piece of writing that quoted it.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 5</h3></div>
<div class="f4">2019-12-30</div></p>
<div class="b"><h5>A concrete starting point</h5></div>
<p>I've managed to come up with a lot of Xanadu-like vaporware ideas in thinking through this tool without producing anything concrete.</p>
<p>Per the above: I'd define my first concrete goal for this library as a replacement for markdown so I can begin to dig myself out of the pit I've put myself in by relying on something I don't like using.</p>
<p>In order to do this, I want to parse markdown into <code class="ws-normal navy">hiccup</code> and pull information out of the file. Whatever replaces markdown will use <code class="ws-normal navy">hiccup</code> data structures anyway, so it's not wasted effort to build functions that process the markdown once it's represented as Clojure data. I can create functions and <code class="ws-normal navy">spec</code>s that define the expected behavior of a markdown replacement.</p>
<p>Based on some unscientific experimentation, the only markdown->hiccup toolchain that properly understands tables is <code class="ws-normal navy">markdown-clj + hickory</code>, so that's what I'll go with. I have a few tests written that don't do much yet.</p>
<p>Other scattered thoughts: </p>
<div class="b"><h5>Plaintext and database</h5></div>
<p>Plain text has a lot of virtues as a long-term storage format, so I plan to make it a core part of however I persist the writing that gets parsed into data by ETN.</p>
<p>The current snapshot and any derived views of it exist should exist as plaintext; its history can be preserved using database backup and persistence methods. But perhaps other defined snapshots in the history of the information should be serialized as plain text as well, in a manner similar to git commits or releases.</p>
<div class="b"><h5>Thoughts on Roam</h5></div>
<p>I signed up for Roam because on paper it seems to be exactly what I want: a PIM with the ability to run arbitary Datalog queries across your thoughts and embed hiccup data structures for visual depictions of the concepts. It's built on Clojure, front to back! What's not to like?</p>
<p>Mostly, the UX. I don't like the aggressively hierarchical format it imposes on all the writing you put into it, I don't like the web interface, which will never be as fast and flexible as plaintext with a good editor, and I don't like the default views it chooses for you.</p>
<p>More than anything, I want a tool of my own making, free from any compromises made to accomodate commercial success or adoption among its target cohort.</p>
<p>I don't want an outlining tool that helps me produce writing. I want a <em>writing</em> tool that helps me identify and work with the structure that emerges from what I write.</p>
<p><em>that and the founder is building the core product around the demands of the LessWrong crowd and goes on [1/178] twitter rants about stuff he reads on SlateStarCodex. the app feels like the product of that kind of approach: unfocused and built around pseudoproblems.</em></p>
<p><div class="b"><h3>Extensible Textual Notation, part 6</h3></div>
<div class="f4">2019-12-31</div></p>
<p>Yesterday I got too caught up reading the documentation for libraries. Today I'm disabling my wifi and striking out into the wilderness with only the standard library (and my reference book) to help me.</p>
<p>First discovery: I probably don't need to use <code class="ws-normal navy">specter</code> when <code class="ws-normal navy">tree-seq</code> will do. <code class="ws-normal navy">clojure.walk</code> will also help, but I don't quite understand it yet.</p>
<p>One thing that occurred to me when thinking about pulling quotes out of plaintext: while an individual paragraph should be the basic semantic unit of my own writing, the basic semantic unit of a quotation or reference should be a sequence of <em>one or more</em> paragraphs. This preserves more of the structure of the origin and aids in its display in other contexts. For storage purposes, though, it should merely be (for now) a sequence of strings. Worrying about the internal structure of the quote itself (lists, etc) can come later when the specs get more refined.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 7</h3></div>
<div class="f4">2020-01-05</div></p>
<p>With a markdown->hiccup parser in hand, I took on a warm-up exercise to map out the problem space and get comfortable with parsing the data I've already dumped in to these markdown files, I defined some contracts for the data formats I want to pull from the textual information using  <code class="ws-normal navy">clojure.spec</code>, which will serve as constraints on the expected behavior of other parsers I write to replace Markdown. It's pretty bare-bones so far, with stuff like the following:</p>
<p><pre class="ws-normal navy bg-silver"><code>(defn same-size? [colls]
  (apply = (map count colls)))
(defn col-kvs? [table-map] (spec/valid? (spec/map-of string? vector?)
                                        (dissoc table-map ::table-meta)))</p>
<p>(spec/def ::same-size same-size?)
(spec/def ::eq-columns #(same-size? (filter sequential? (vals %))))
(spec/def ::col-kvs col-kvs?)</p>
<p>(spec/def ::table-whole-meta map?)
(spec/def ::table-body-meta map?)
(spec/def ::table-header-meta map?)</p>
<p>(spec/def ::table-meta
  (spec/keys :req [::table-whole-meta ::table-body-meta ::table-header-meta]))</p>
<p>(spec/def ::tidy-table
  (spec/and
   (spec/keys :opt [::table-meta])
   ::col-kvs
   ::eq-columns))
</code></pre></p>
<p>These plus some functions to transform parsed <code class="ws-normal navy">hiccup</code> data structures into these canonical formats will allow me to capture some of the emergent structure of what I've already written here. Using <a href="https://github.com/Provisdom/spectomic"><code class="ws-normal navy">spectomic</code></a> I can define the constraints using spec and automatically generate <code class="ws-normal navy">datahike</code> schemas from them.</p>
<p>But that's only the starting point. The real purpose here is to replace <code class="ws-normal navy">markdown</code> with a notation format that represents <em>text as data</em> and lets the user easily convey other types of structured data within the text itself. To that end, I have to come up with a different format for notating the documents, a very brief example of this I sketched out above.</p>
<p>There is plenty of prior art for this: I generated the first version of this blog using <code class="ws-normal navy">pollen</code>. I wanted to learn about the way <code class="ws-normal navy">scribble</code>, on which <code class="ws-normal navy">pollen</code> is built parses plaintext into Racket data structures for manipulation, but the library is quite complex (the documentation is fantastic, but it focuses mostly on the API rather than how the parsers and readers are implemnted interally). It also reimplements much of what I intend to use <code class="ws-normal navy">hiccup</code> to do.</p>
<p>Luckily, I have been spared the experience of suffering through the entire <code class="ws-normal navy">scribble</code> codebase by Bogdan Opanchuk's <a href="https://github.com/fjarri/clojure-scribble">Clojure implementation</a>. I could simply use it directly, but I'm not interested in taking more shortcuts and adding more libraries to this project, especially when I know I'll have to add my own syntax to the notation and the parser rules to support them. I also won't really understand the way these parsers work unless I go forth and implement one myself. Fortunately, the project uses <code class="ws-normal navy">marginalia</code> to give a guided tour through the internals of the code. This library may not be as comprehensive as the original implementation of <code class="ws-normal navy">scribble</code>, but Clojure's expressivity makes it far easier to understand the global structure of this smaller implementation and thus learn from it. </p>
<p>Rather than a <a href="https://spec.commonmark.org/">plaintext spec that monotonically grows in complexity</a> due to the workarounds to handle the corner cases generated by ambiguous syntax, I'm hoping to define as much of the expected structure using <code class="ws-normal navy">clojure.spec</code>, which strikes the right balance between the rigidity of a BNF grammar and the ambiguity of a plaintext spec, plus the additional leverage that comes with defining a spec as code: the ability to <a href="https://clojure.org/guides/spec#_custom_generators">generate arbitary adversarial examples</a> to ensure that corner cases are found quicker and dealt with in a more systematic fashion.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 8</h3></div>
<div class="f4">2020-01-11</div></p>
<p>One motivation for this concept was an incredibly useful design exercise when I was building a backend system at work: creating a <a href="https://www.evanmiller.org/feature-matrix.html">feature matrix</a> for the various sub-components to understand their interactions with one another and how those translate into both library code and user-facing features. (read Evan Miller's whole essay; it's a quick read and a succinct, lucid statement of a very powerful idea). In order to produce one, I had to step outside of my trusty text editor and flip over to Google Sheets to create a NxN grid, fill it up with the pair-wise interactions between the components, and then use an unholy spreadsheet formula to transpose those comma-delimited features into a discrete list with separate references to each column in the body of the matrix:</p>
<pre class="ws-normal navy bg-silver"><code>=unique(transpose(split(join("|", 'Sheet1'!$B$3:$B$17, 'Sheet1'!$C$3:$C$17, 'Sheet1'!$D$3:$D$17, ... "|")))</code></pre>
<p>It was the most beautiful <a href="https://wiki.c2.com/?WaterfallModel">waterfall planning</a> I've ever done. As you'd expect, looking back over the matrix now, I see how hopelessly out of date it is and how badly it serves its original purpose of defining tasks with enough granularity to yield tickets. </p>
<p>The codebase is always the most up-to-date part of any software project. Everything else tends to lag behind, mostly due to the unavoidable fact that you don't always know what you need to build before you build it. But why can't we write documents in a way that lends itself a little better to the day-to-day work of software development? Why can't I plop a feature matrix right into my <code class="ws-normal navy">readme</code> and then programatically generate a set of test suites for the features within it? That way, by changing the top-level description of the project, I also change the definition of the software that ensures it functions as intended.</p>
<p><em>please do not tell me that org-mode supports tables. I am not interested in a solution specific to emacs lisp that imposes a separation  between structured data and code by tangling out the code into separate files, and thus remains ignorant of the actual information generated by that code.</em></p>
<p>You might say something like "design should be design, and code should be code. Just because a problem is represented a certain way in the design phase doesn't mean that the actual code should be laid out that way."  I agree with part of the spirit behind this. Stepping away from the laptop to think through the problem is something that everyone should do more often. I deeply enjoy the more embodied sense of problem-solving that sketching on a whiteboard gives me. But sometimes, you need more than a sketch or description; structured data can represent facts about a codebase that spec documents and architecture diagrams cannot. Keeping this up-to-date means seeing and editing it directly in tandem with the code. It means automatically checking off one of the "to-dos" generated from the structured documentation when a given test passes. It means storing information about failed and successful builds not in some <a href="https://docs.gitlab.com/ee/ci/pipelines.html">web interface that has no direct interaction with the code</a> but perhaps in the same data structure as the code itself.</p>
<p>Saying something like "code should look like code" assumes that we can only have one canonical way of representing the data that ultimately forms the program. But a richer data structure than flat files (like a CRDT) could be made to form the backend of multiple representations, one "API-first" view according to the code layout and another "feature-first" view according to the table of requirements. What if you could filter down the test suites you run as easily as filtering a spreadsheet? (you might call this way of interacting with the code <em>view-inspired, model-driven</em>, to borrow a term from Chiusano's essay I link above).</p>
<p>Sometimes it feels like our mental model of tooling for software still comes from a pre-network era, where the notion of the software <em>artifact</em> prevails and tools for managing individual artifacts win the day. They define the software we write as a discrete <em>closed system</em>, and then we bolt more complexity back on to get around this model. It's why we ship around many megabytes more code than we need to when checking out a function from a library and it's why revision control operates fundamentally at the level of a single folder rather than the sub-units defined by the code within that folder - we ship around the whole folder because that's what we have isolated and replicable history for. Software still yields artifacts: docker images, executable binaries, etc. That hasn't gone away (and it won't until we're all using ultra-live environments that live up to the legacy of the first Smalltalk systems), but now code is much more likely to be a part of a <em>open system</em> that interacts with build tools, clusters of virtual machines, live data stores, and the like. The mess of information those tools generate informs choices about the code we write, so why not figure out a way to represent the information we need closer to the code itself?</p>
<p>For one possible foundation for a different approach to managing the history of code, see Unison's concept of <a href="https://www.unisonweb.org/docs/tour">content-addressed code.</a> Content-addressing and tracking the history of functions as individual units means that they can break out of their original repos while maintaining their lineage. Instead of snapshots of whole libraries, functions could migrate from one library to another, picking up unique changes as they propagate their descendants into that new project's context. Code would have a <em>genealogy</em> rather than <em>dependencies</em>. Similarly, I think there's a lot of potential power in storing arbitrary structured data in the same data structure as the code itself. We haven't really taken the conceptual leap towards developing applications around that model because we default to git for any new project and thus rely on its implicit view of the world. Hopefully that can change.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 9</h3></div>
<div class="f4">2020-01-11</div></p>
<p>Turns out I was more right about needing to implement my own <code class="ws-normal navy">scribble</code>-like syntax than I knew, because while taking the clojure implementation out for a spin, I discovered that it relies heavily on an <a href="https://github.com/jwymanm/chiara">unmaintained set of reader macros</a> that are incompatible with recent versions of Clojure because <code class="ws-normal navy">clojure.spec</code> now enforces compile-time syntax of macros (like <code class="ws-normal navy">defn</code>).</p>
<p>I'm going to have to write my own text->EDN parser that replicates what <code class="ws-normal navy">scribble</code> relies on reader macros to do. I'm fortunately <em>not</em> trying to alter in any fundamental way how Clojure data is transformed into its AST; I'm just doing some preprocessing on plaintext so it's the right shape when it hits the clojure reader. Into the wilderness.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 10</h3></div>
<div class="f4">2020-01-21</div></p>
<p>While I have a decent enough concept of the _source_ of the data generated through writing in plaintext, I don't yet have a good concept of the _target_ of that data. I intend to use `datahike` as a persistent storage format, but it's daunting to think about where to start.</p>
<p>Here's a good bootstrapping exercise for understanding the format and how it works: a quotes page in Perun. It will read a <code class="ws-normal navy">quotes.edn</code> file, dump the data parsed out from that quotes file into a <code class="ws-normal navy">datahike</code> db, and then use that data to generate the <code class="ws-normal navy">hiccup</code> content for the page. Once that's in place, I'll have a better idea of the schema I need to yank quotes out of the posts where they're quoted and add them to this DB.</p>
<p>One important benefit of using functions rather than markup to define quotes is the ability to <em>preserve context</em> by including the references back to the piece of writing containing the quotes. This was one of the great promises of project Xanadu, the ability to see in tandem the multiple layers of context surrounding a link to a passage from another page. I cannot create a system as fully dynamic as Xanadu, but I can use an intermediate evaluation step as text is read from its input format to capture the structure created by the text and its references.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 11</h3></div>
<div class="f4">2020-03-07</div></p>
<p>After a couple of half-hearted attempts to replicate the lozenge syntax of <code class="ws-normal navy">pollen</code> using a Clojure <code class="ws-normal navy">ANTLR</code> parser, I discovered the very new but very fully-featured <a href="https://github.com/vivid-inc/ash-ra-template"><code class="ws-normal navy">ash-ra-template</code></a> library. </p>
<p>While I recognize that building my own parser is a good programming challenge, I also need to ask myself whether I need to undertake it before doing the work that I want to do in a medium that actually supports it. Right now, I'd prefer the latter.</p>
<p><div class="b"><h3>Extensible Textual Notation, part 12</h3></div>
<div class="f4">2020-03-23</div></p>
<p>The text has extended itself beyond the limitations of Markdown. I now have the power of a real programming language at my disposal in my own writing, and I used it to replace every single backtick and bracket that Markdown required. In so doing, I more fluidly composed the structures provided by HTML by using tools better designed to manipulate them directly instead of burying them under a pre-selected menu of abstractions. I understand HTML better as a result - its structure was not hidden from me. By using a dynamic, computational medium for writing, I can perform Jenny Odell calls "context creation" - I can fully express the context of this page's own creation, false starts, half-baked parsers, and all.</p>
<p>I just wish it hadn't taken until a <a href="https://en.wikipedia.org/wiki/2019%E2%80%9320_coronavirus_pandemic">once-in a generation global crisis</a> to get here.</p>
<p><div class="b"><h3>Paragraph detection within <code class="ws-normal navy">ash-ra-template</code></h3></div>
<div class="f4">2020-03-29</div></p>
<p>Overall, I'm quite pleased with how well <code class="ws-normal navy">ash-ra-template</code> is working to directly create HTML using the power of Clojure and hiccup only when I need it. Now that I know how to make my own rendering library <a href="https://github.com/vivid-inc/ash-ra-template/issues/2">available to <code class="ws-normal navy">ash-ra-template</code></a>, I'm seamlessly replacing Markdown's defaults with functions that I have total control over. But there's one thing missing from the experience of using markdown or other plaintext formats - paragraph detection. If I want paragraphs now, I have to insert <code class="ws-normal navy">[:p "content"]</code> blocks, which effectively means I'm <em>just</em> writing in hiccup data structures and not plaintext, defeating the purpose of using a templating engine at all.</p>
<p>Luckily, the documentation for <a href="https://docs.racket-lang.org/pollen/third-tutorial.html"><code class="ws-normal navy">pollen</code></a> suggests a path forward: post-processing the text after template evaluation to infer paragraph and linebreaks. The documentation for the <a href="https://docs.racket-lang.org/pollen/Decode.html#%28def._%28%28lib._pollen%2Fdecode..rkt%29._decode-paragraphs%29%29"><code class="ws-normal navy">detect-paragraphs</code> function</a> also has some useful test cases for paragraph inference on the basis of pre-existing blocks.</p>
<p>Tokenizing the text into paragraphs after evaluation also potentially allows for the recording of the text as facts in a database (see above). I'm not there yet, but I'm about to merge into master and leave Markdown behind for good. </p>
<p><div class="b"><h3>Holotype: further steps towards simplicity</h3></div>
<div class="f4">2020-04-11</div></p>
<p>I made good progress generating content with <code class="ws-normal navy">ash-ra-template</code> - until I wanted to dynamically render an image as part of the build process. I ran into two walls imposed by the closed environment of <code class="ws-normal navy">ShimDandy</code>: lack of access to the local filesystem, and the Java classes necessary to render images using <code class="ws-normal navy">clojure2d</code> are not available in that context either.</p>
<p>Fortunately, I recently discovered <a href="https://github.com/weavejester/comb"><code class="ws-normal navy">comb</code></a>, a library much like <code class="ws-normal navy">ash-ra-template</code> by the author of <code class="ws-normal navy">hiccup</code>, which is pretty much <em>exactly</em> what I was thinking about building above, and its parser is exceptionally simple. It lets me seamlessly embed generative artwork into my pages as easily as I can use my templating functions to emphasize text or add headers. You can see an example <a href="holotype.html">here.</a></p>
<p>In addition to that, the fact that the templates are evaluated in the same context as the rest of my code adds the following benefits:
<ul><li>I can define a map of metadata attributes at the top of the post that is available to the rendering function, so I can set page-level attributes from within each post itself - no kludges like <a href="https://github.com/hashobject/perun/blob/ca090ca77a3aac18b4ff0ac330febb88c26cab84/src/io/perun/yaml.clj">YAML front matter</a> - I handle my posts' data in pure Clojure.</li><li>I no longer need to install my rendering code to my local maven repo to call it from the templates, which lets me</li><li>rebuild all the pages from the REPL, and</li><li>rebuild the pages <em>much</em> faster</li></ul></p>
<p>It even uses the same delimiters, which made it trivial to port all my existing pages over to the new library and simplify my project into a single namespace.</div></body><footer class="mb7"><div><a href="/">Home</a></div></footer></article></html></p>