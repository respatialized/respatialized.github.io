<!DOCTYPE html>
<html><head><title>Respatialized | Database-driven applications</title><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport" /><script async="async" src="js/prism.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js" type="text/javascript"></script><link href="css/fonts.css" rel="stylesheet" type="text/css" /><link href="css/main.css" rel="stylesheet" type="text/css" /><style>figure figcaption {
  font-style: italic;
}

figure img {
  margin: auto;
}

h1 {
  break-after: all;
}

h3 {
  font-size: 1.8rem;
}

article {
  column-count: 2;
  max-width: 1300px;
}

article section {
  break-after: column;
  max-width: 35rem;
  break-inside: avoid;
}</style></head><body><article lang="en"><section><p>


</p><header><h1>Database-driven applications</h1></header></section><section><header><h3>How applications usually get made</h3></header><figure class="svg-diagram"><img alt="" class="w-50" src="media/api-diagram.svg" /><figcaption>A &apos;traditional&apos; MVC-esque architecture with an API</figcaption></figure><p>At each component boundary, there lies the potential for an impedance mismatch: due to some technology or system constraint, some critical piece of the information model doesn&apos;t make it across the boundary.</p><ol><li><ul><li>The data model may be difficult to express in the constraints of the storage medium (e.g. SQL)</li><li>The data model is expressed too concretely in the DB (e.g. JSON columns, document stores)</li></ul></li><li><ul><li>The data model may not match the constraints of the communication layer (e.g. REST/HTTP)</li><li>The API only exposes a limited subset of the information model</li></ul></li><li><ul><li>The front end, as a privileged part of the application, gets to talk to the information model directly and bypass the API&apos;s limitations</li></ul></li><li><ul><li>The API exposed to external programs only sees a limited subset of the &apos;true&apos; API</li></ul></li></ol></section><section><header><h3>A simple alternative</h3></header><figure class="svg-diagram"><img alt="" class="w-50" src="media/schema-diagram.svg" /><figcaption>Schema as united information model and API</figcaption></figure><p>Just let a program run queries against the database. Let me make a TODO on my TODO list by transacting an assertion.</p><p>In order for this to be a viable solution, several assumptions must hold:</p><ul><li>You need a very expressive query language. (sorry, SQL)</li><li>You need to give the user unmediated access to their data. (sorry, webapps)</li><li>&apos;Scalability&apos; is not a concern. (sorry, webapps)</li><li>You need to parse and validate the query to eliminate pathological/hostile inputs. (sorry, SQL)</li></ul><p>In short, this solution really only works in the context of <a href="https://www.inkandswitch.com/local-first.html">local-first software</a>.
</p></section></article><footer class="mb7"><div><a href="/">Home</a></div></footer></body></html>